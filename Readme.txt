Για την ευκολότερη και καλύτερη μεταγλώττιση του προγράμματος δημιουργήθηκε το 
αντίστοιχο Makefile. Ο κώδικας έχει δομηθεί έτσι ώστε σε ένα τερματικό να τρέχει
ο server και κάθε εντολή του commander σε διαφορετικό.

Ο κώδικας έχει τμηματόποιηθει έτσι ώστε να είναι πιο κατανοητός και να υπάρχει 
καλή απόκρυψη πληροφορίας. Ειδικότερα αποτελείται από :

->  Για να εξαρφαλιστεί οτι είναι thread-safe χρησιμοποιούνται mutexes και 
    condition variables.

1. jobCommander.c : Αρχικά ελέγχει την ορθότητα της εντολής και των ορισμάτων 
που πληκτρολογεί ο χρήστης. Έπειτα δημιουργεί το socket για την επικοινωνία.
Ύστερα, γράφει την αντίστοιχη εντολή και αναμένει απάντηση. Έαν πρόκειται για
εντολή issueJob αναμένει δύο απαντήσεις, μια ότι καταχωρήθηκε και μια το απο-
τέλεσμα. Σε κάθε περίτωση εκτυπώνονται τα αντίστοιχα μηνύματα στο τερματικό.

2. jobExecutorServer.c : Ο server δημιουργεί και κάνει bind το socket, αρχι-
κοποιέι τα work threads. Έπειτα εισέρχεται σε έναν άπειρο βρόχο όπου δέχε-
ται συνδέσεις. Για κάθε αποδεκτή σύνδεση, δημιουργείται ένα νέο νήμα 
controller. Το νήμα αυτό είναι υπεύθυνο για το χειρισμό των εντολών του συγκε-
κριμένου πελάτη.

    * Worker threads : περιμένουν να είναι διαθέσιμες θέσεις εργασίας στην ουρά. 
    Αυτή η διαχείριση γίνεται με τη χρήση condition variables για την αποφυγή 
    busy-waiting.
    Όταν προστεθεί μια δουλειά το νήμα ανακτά από την ουρά, εκτελεί την εργασία
    με την χρήση execvp. Η έξοδος της εργασίας ανακατευθύνεται σε ένα αρχείο.
    Αφού ολοκληρωθεί η εκτέλεση της εργασίας, ο πατέρας διαβάζει το αρχείο 
    εξόδου και στέλνει τα περιεχόμενα πίσω στον πελάτη. Στη συνέχεια, η εργασία 
    αφαιρείται από την ουρά και ελέγχεται εάν υπάρχουν τυχόν εργασίες που
    αναμένουν.

    * Controller threads : Χειρίζεται τις εντολές ως εξής:

    * issueJob : Στην υλοποίηση αυτή διατηρώ μια ουρά running, όπου με βάση 
    το concurrency τοποθετείτε στην σωστή ουρά. 

    * setConcurrency : Εάν τροποποιηθεί το concurency ελέγχω έαν είναι μικρό-
    τερο απο το buffer_size και μικρότερο απο το thread_pool_size και μόνο
    τότε το αλλάζω. Διαφορετικά παραμένει η προηγούμενη τιμή, καθώς δεν μπο-
    ρω να ξεπεράσω το μέγεθος του buffer ή τον αριθμό των διαθέσιμων thread.
    Έαν αυξηθεί το concurrency ελέγχω εάν υπάρχει κάτι που να αναμένει, ενώ 
    εάν μειωθεί, αλλάζω το concurrency και περιμένω να τελειώσουν οι ήδη 
    ενεργές δουλειές.

    * stop : Με βάση το jobId διαγράφει τη δουλειά από την ουρά, εφόσον αυτή
    δεν εκτελείται. Εάν εκτελείται ή δεν υπάρχει, δεν κάνει κάποια ενέρεγια.

    * poll : Εμφανίζει μια λίστα με τις δουλειές που δεν εκτελούνται.

    * exit : Ορίζει το concurency με μηδέν, σκοτώνει όσες δουλειές δεν έχουν 
    ξεκινήσει την εκτέλεση τους και περιμένει όσες εκτελόυνται με την 
    pthread_join(workerthreads[i], NULL). Σε κάθε περίτωση εκτυπώνονται τα 
    αντίστοιχα μηνύματα στο τερματικό.

3. myheaders.h : Πρόκειται για το αρχείο επικεφαλίδας το οποίο περιέχει κάποιες
κοινόχρηστες μεταβλητές (extern int Concurrency, extern int buffer_size) και τα 
πρότυπα των δικών μου συναρτήσεων που αξιοποιούν ο server και ο commander.

4. queue.h : Πρόκειται για το αρχείο επικεφαλίδας που περιέχει τα πρότυπα των 
συναρτήσεων που χρησιμοποιεί η ουρά. Πρόκειται για μια δυναμική υλοποίηση,
παρόμοια με αυτήν που χρησιμοποιήθηκε στην προηγούμενη άσκηση.

5. queue.c : Εδω, βρίσκεται η υλοποίηση των βασικών συναρτήσεων της ουράς.
